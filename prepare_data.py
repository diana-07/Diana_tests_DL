# -*- coding: utf-8 -*-
"""prepare_data.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ng9dkLPpKvI9wbal9fT-Tc2e_9t22Z7a
"""

# !pip uninstall -y mediapipe-silicon
# !pip uninstall -y mediapipe
# !pip uninstall -y protobuf
# !pip install protobuf==3.20.3  # Specific version that often works well with MediaPipe
# !pip install mediapipe

import os
import cv2
import torch
import numpy as np
from tqdm import tqdm
from collections import defaultdict
from sklearn.model_selection import train_test_split
import random
# import mediapipe as mp
# import torch.nn as nn
# from torch.utils.data import Dataset, DataLoader, random_split
# import torchvision.transforms as T
# import torchvision.models as models
# from PIL import Image
# from sklearn.metrics import accuracy_score
# import shutil





def convert_video_to_npy(video_path, resize_shape=(224, 224)):
    """
    Converts a video to a numpy array of resized frames.

    Parameters:
    - video_path: The path to the video file.
    - resize_shape: The desired frame size (default is 224x224).

    Returns:
    - frames_array: Numpy array containing all frames.
    """
    cap = cv2.VideoCapture(video_path)
    frames = []

    if not cap.isOpened():
        raise ValueError(f"Error opening video file: {video_path}")

    while True:
        ret, frame = cap.read()
        if not ret:
            break
        # Resize frame to the desired shape
        frame_resized = cv2.resize(frame, resize_shape)
        frames.append(frame_resized)

    cap.release()

    # Convert list of frames into a numpy array
    frames_array = np.array(frames)
    return frames_array

def create_subfolders(pastas_dir, output_dir):
    """
    Creates subfolders in the output directory and processes .avi files.

    Parameters:
    - pastas_dir: The root directory containing class folders.
    - output_dir: The directory where the .npy files will be saved.
    """
    for pastas_filename in os.listdir(pastas_dir):
        origem_path = os.path.join(pastas_dir, pastas_filename)

        # Check if it's a directory (ignore files)
        if os.path.isdir(origem_path):
            nova_pasta_path = os.path.join(output_dir, pastas_filename)
            os.makedirs(nova_pasta_path, exist_ok=True)

            # Process each video file in the subfolder
            videos_dir = os.path.join(pastas_dir, pastas_filename)
            for video_filename in os.listdir(videos_dir):
                if video_filename.endswith(".avi"):  # Process only .avi files
                    video_path = os.path.join(videos_dir, video_filename)
                    video_name = os.path.splitext(video_filename)[0]

                    try:
                        # Convert the video to numpy array
                        frames_array = convert_video_to_npy(video_path)

                        # Save the numpy array to a .npy file
                        output_filename = os.path.join(nova_pasta_path, f"{video_name}.npy")
                        np.save(output_filename, frames_array)
                    except ValueError as e:
                        print(f"Error processing {video_filename}: {e}")
                    except Exception as e:
                        print(f"Unexpected error with {video_filename}: {e}")

# Pad/truncate to 120 frames
def pad_or_truncate_keypoints(keypoints, target_length=120):
    """
    Pads or truncates a keypoints array to a fixed number of frames (target_length).
    If padding is needed, uses zeros.
    """
    current_length = keypoints.shape[0]

    if current_length == target_length:
        return keypoints
    elif current_length > target_length:
        return keypoints[:target_length]  # Truncate
    else:
        # Pad with zeros
        padding = np.zeros((target_length - current_length, keypoints.shape[1], keypoints.shape[2]))
        return np.concatenate([keypoints, padding], axis=0)

def extract_player_id(filename):
    # Example: 'player1_video1.npy' → 'player1'
    return filename.split('_')[0]

def collect_by_players(player_ids, player_video_map, all_keypoints):
    dataset = []
    for pid in player_ids:
        for action, filename in player_video_map[pid]:
            keypoints = all_keypoints[action][filename]
            dataset.append((keypoints, action))
    return dataset




    

if __name__ == '__main__': #precisa de estar para a parte inicial em .ipynb

  #PRINTS FINAIS

  #1ST PHASE - check pastes ##################################
  print("CUDA available:", torch.cuda.is_available())
  print("Device name:", torch.cuda.get_device_name(0) if torch.cuda.is_available() else "No GPU")

  print(os.listdir('VIDEO_Skelet3D'))

  #############################################################

  #2ND PHASE - create subfolders and convert files to .npy
  # Example usage
  pastas_dir = 'VIDEO_Skelet3D'  # Directory with .avi videos
  npy_dir = 'npy_videos'  # Directory to save .npy files
  os.makedirs(npy_dir, exist_ok=True)

  # Process videos and maintain class folders
  create_subfolders(pastas_dir, npy_dir)
    
  print("Fim da execução do prepare_data.py")

  